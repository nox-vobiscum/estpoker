<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" th:lang="${#locale}" lang="en">
<head th:replace="~{fragments/head :: head}"></head>
<body>

  <!-- Global app menu (full menu in the room) -->
  <div th:replace="~{fragments/menu :: appMenu(showSeq=${true}, showAuto=${true}, showRoom=${true})}"></div>

  <div class="container">
    <h1 class="app-title">
      <img src="/favicon.svg" alt="" width="24" height="24" class="logo">
      <span th:text="#{ui.heading}">RBS' Estimation Poker</span>
    </h1>

    <!-- You + room info -->
    <dl class="main-info">
      <dt><span class="mi-icon" aria-hidden="true">ğŸ‘¤</span><span class="mi-label" th:text="#{label.you}">You are:</span></dt>
      <dd><strong id="youName" th:text="${participantName}">Guest</strong></dd>

      <dt><span class="mi-icon" aria-hidden="true">ğŸ†”</span><span class="mi-label" th:text="#{label.room}">Room:</span></dt>
      <dd>
        <div class="room-with-actions">
          <strong id="roomCodeVal" th:text="${roomCode}">demo</strong>
          <button id="copyRoomLink"
                  class="icon-button"
                  type="button"
                  th:attr="aria-label=#{invite.copyLink},data-tooltip=#{invite.copyLink}"
                  aria-live="polite">ğŸ”—
          </button>
        </div>
      </dd>
    </dl>

    <h2 th:text="#{label.participants}">Participants</h2>
    <ul id="liveParticipantList"></ul>

    <!-- Topic (Ticket/Story) â€” compact row (everyone) + editor row (host only) -->
    <div id="topicRow" class="topic-row" style="display:none;">
      <span class="topic-label" aria-hidden="true">ğŸ“</span>
      <span id="topicDisplay" class="topic-text">â€”</span>
      <div class="topic-actions">
        <!-- Host-only buttons; hidden for participants via JS -->
        <button id="topicEditBtn" class="row-action" type="button" data-tooltip="Edit" aria-label="Edit">
          <span class="ra-icon">âœï¸</span><span class="ra-label">Edit</span>
        </button>
        <button id="topicClearBtn" class="row-action kick" type="button"
                th:attr="data-tooltip=#{button.clearTopic},aria-label=#{button.clearTopic}">
          <span class="ra-icon">ğŸ§¹</span><span class="ra-label" th:text="#{button.clearTopic}">Clear</span>
        </button>
      </div>
    </div>

    <div id="topicEdit" class="topic-edit" style="display:none;">
      <input id="topicInput"
             class="topic-input"
             type="text"
             th:attr="placeholder=#{topic.placeholder}"
             placeholder="Paste JIRA link or type key (e.g., RBSEP-123)â€¦">
      <div class="topic-actions">
        <button id="topicSaveBtn" class="row-action host" type="button"
                th:attr="data-tooltip=#{button.saveTopic},aria-label=#{button.saveTopic}">
          <span class="ra-icon">âœ…</span><span class="ra-label" th:text="#{button.saveTopic}">Save</span>
        </button>
        <button id="topicCancelBtn" class="row-action" type="button" data-tooltip="Cancel" aria-label="Cancel">
          <span class="ra-icon">âŒ</span><span class="ra-label">Cancel</span>
        </button>
      </div>
    </div>

    <h2 id="selectCardHeader" th:text="#{label.selectCard}">Choose a card:</h2>

    <div class="pre-vote">
      <div id="cardsArea"></div>
      <button type="button" id="revealButton" class="button" style="display:none;"
              th:text="#{button.reveal}" onclick="revealCards()">Reveal cards</button>
    </div>

    <div class="post-vote" style="display:none;">
      <p id="resultRow"
         class="average-label consensus-row"
         role="status"
         aria-live="polite"
         aria-atomic="true">
        <span id="resultLabel" class="label" th:text="#{label.average}">Avg:</span>
        <span id="averageVote" class="value">â€“</span>

        <span class="sep" aria-hidden="true"> â€¢ </span>

        <span id="medianWrap" class="stat" hidden>
          <span id="medianLabel" class="label" th:text="#{label.median}">Median:</span>
          <span id="medianVote" class="value">â€“</span>
        </span>

        <span class="sep" aria-hidden="true" id="rangeSep" hidden> â€¢ </span>

        <span id="rangeWrap" class="stat" hidden>
          <span id="rangeLabel" class="label" th:text="#{label.range}">Range:</span>
          <span id="rangeVote" class="value">â€“</span>
        </span>
      </p>

      <button type="button" id="resetButton" class="button" style="display:none;"
              th:text="#{button.reset}" onclick="resetRoom()">Start new round</button>
    </div>
  </div>

  <!-- Central scripts (must be before inline JS so defer-order is correct) -->
  <th:block th:replace="~{fragments/scripts :: scripts}"></th:block>

  <script th:inline="javascript">
  /* ======================= Game logic ============================ */

  let participantName   = /*[[${participantName}]]*/ "Guest";
  let roomCode          = /*[[${roomCode}]]*/ "demo";
  let selectedCard      = null;
  let votesRevealed     = false;
  let isHost            = false;
  let resizeTimer       = null;
  let currentSequenceId = 'fib-scrum';
  let currentDeckSig    = "";

  let myParticipating   = true;

  const TXT_AVG            = /*[[#{label.average}]]*/ 'Avg:';
  const TXT_CONS           = /*[[#{label.consensus}]]*/ 'Consensus:';
  const TXT_MEDIAN         = /*[[#{label.median}]]*/ 'Median:';
  const TXT_RANGE          = /*[[#{label.range}]]*/ 'Range:';
  const TXT_OUTLIER_HINT   = /*[[#{hint.outlier}]]*/ 'Farthest from average';
  const TXT_ON             = /*[[#{toggle.on}]]*/ 'On';
  const TXT_OFF            = /*[[#{toggle.off}]]*/ 'Off';
  const TXT_AR_ONLY_HOST   = /*[[#{autoreveal.onlyHost}]]*/ 'Only the host can change this setting.';
  const TXT_MAKE_HOST      = /*[[#{action.makeHost}]]*/ 'Make host';
  const TXT_KICK           = /*[[#{action.kick}]]*/ 'Kick';
  const TXT_KICKED         = /*[[#{toast.kicked}]]*/ 'The host has closed the room for you.';
  const TXT_IM_IN          = /*[[#{participation.imIn}]]*/ "I'm estimating";
  const TXT_OBSERVER       = /*[[#{participation.observer}]]*/ "Observer";
  const TXT_OBS_NO_PICK    = /*[[#{observer.noPick}]]*/ 'As an observer you canâ€™t pick a card.';
  const TXT_TOPIC_SAVED    = /*[[#{topic.saved}]]*/ 'Topic saved';
  const TXT_TOPIC_CLEARED  = /*[[#{topic.cleared}]]*/ 'Topic cleared';

  let autoRevealEnabled = false;
  let topicVisible      = true;
  let isEditingTopic    = false;

  const SPECIALS = new Set(["â“","ğŸ’¬","â˜•"]);
  const SEQ_CATALOG = Object.create(null);

  function formatDeckForTooltip(cards){
    if (!Array.isArray(cards)) return '';
    const specials = cards.filter(c => SPECIALS.has(String(c)));
    const core     = cards.filter(c => !SPECIALS.has(String(c)));
    const max      = 12;
    const shown    = core.slice(0, max);
    const more     = core.length > max ? 'â€¦' : '';
    const coreTxt  = shown.join(', ') + (more ? ' ' + more : '');
    const specTxt  = specials.length ? '  (' + specials.join(' ') + ')' : '';
    return coreTxt + specTxt;
  }
  function updateSequenceTooltips(){
    const inputs = document.querySelectorAll('#seqChoice .radio-row input[name="seq"]');
    inputs.forEach(inp=>{
      const row = inp.closest('.radio-row');
      if(!row) return;
      const id   = inp.value;
      const deck = SEQ_CATALOG[id];
      if (deck && deck.length){
        const tip = formatDeckForTooltip(deck);
        row.setAttribute('data-tooltip', tip);
        row.removeAttribute('title');
      } else {
        row.removeAttribute('data-tooltip');
        row.removeAttribute('title');
      }
    });
  }

  function addCardButton(grid, val){
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.setAttribute('data-card', val);
    btn.textContent = val;
    btn.addEventListener('click', () => {
      if (!myParticipating) { showToast(TXT_OBS_NO_PICK); return; }
      if (votesRevealed)    { return; }
      sendVote(val);
    });
    grid.appendChild(btn);
  }
  function deckSig(arr){ return Array.isArray(arr) ? arr.join("|") : ""; }

  function renderCards(deck){
    const area = document.getElementById('cardsArea');
    if (!area || !Array.isArray(deck)) return;
    const regular  = deck.filter(v => !SPECIALS.has(v));
    const specials = deck.filter(v =>  SPECIALS.has(v));
    area.innerHTML = '';
    const grid = document.createElement('div');
    grid.className = 'card-grid';
    regular.forEach(val => addCardButton(grid, val));
    area.appendChild(grid);
    if (specials.length){
      const sgrid = document.createElement('div');
      sgrid.className = 'card-grid';
      specials.forEach(val => addCardButton(sgrid, val));
      area.appendChild(sgrid);
    }
    updateCardInteractivity(myParticipating);
    highlightSelectedCard();
  }

  function updateCardInteractivity(canPick){
    const buttons = document.querySelectorAll('.card-grid button');
    const disableAll = !canPick || !!votesRevealed;
    buttons.forEach(btn => {
      btn.disabled = disableAll;
      if (disableAll) {
        btn.setAttribute('data-tooltip', !canPick ? TXT_OBS_NO_PICK : '');
        btn.setAttribute('tabindex', '-1');
      } else {
        btn.removeAttribute('data-tooltip');
        btn.removeAttribute('tabindex');
      }
    });
  }

  function syncSequenceUI(){
    const radios = document.querySelectorAll('#seqChoice input[name="seq"]');
    radios.forEach(r => {
      r.checked = (r.value === currentSequenceId);
      r.disabled = !isHost;
      r.closest('.radio-row')?.classList.toggle('disabled', !isHost);
    });
    const hint = document.getElementById('seqHint');
    if (hint) hint.style.display = isHost ? 'none' : 'block';
  }
  function syncAutoRevealUI(){
    const row = document.getElementById('autoRevealRow');
    const st  = document.getElementById('arStatus');
    const cb  = document.getElementById('autoRevealToggle');
    if (st) st.textContent = autoRevealEnabled ? TXT_ON : TXT_OFF;
    if (cb) {
      cb.checked = autoRevealEnabled;
      cb.setAttribute('aria-checked', autoRevealEnabled ? 'true' : 'false');
      cb.disabled = !isHost;
    }
    if (row) row.classList.toggle('disabled', !isHost);
    const hint = document.getElementById('arHint');
    if (hint) hint.style.display = isHost ? 'none' : 'block';
  }
  /* NEW: keep Topic toggle visuals consistent with Auto-Reveal for non-hosts */
  function syncTopicToggleUI(){
    const row = document.getElementById('topicToggleRow');
    const st  = document.getElementById('topicStatus');
    const cb  = document.getElementById('topicToggle');
    if (st) st.textContent = topicVisible ? TXT_ON : TXT_OFF;
    if (cb) {
      cb.checked = topicVisible;
      cb.setAttribute('aria-checked', topicVisible ? 'true' : 'false');
      cb.disabled = !isHost;                // disable switch for non-hosts
    }
    if (row) row.classList.toggle('disabled', !isHost); // dim whole row
  }

  function updateTopicDisplay(label, url){
    const disp = document.getElementById('topicDisplay');
    if (!disp) return;
    if (!label && !url) {
      disp.textContent = 'â€”';
      return;
    }
    if (url) {
      const a = document.createElement('a');
      a.href = url; a.target = '_blank'; a.rel = 'noopener';
      a.textContent = label || url;
      disp.innerHTML = '';
      disp.appendChild(a);
    } else {
      disp.textContent = label;
    }
  }

  function applyTopicUI(){
    const st = document.getElementById('topicStatus');
    if (st) st.textContent = topicVisible ? TXT_ON : TXT_OFF;

    const row  = document.getElementById('topicRow');
    const edit = document.getElementById('topicEdit');
    const editBtn  = document.getElementById('topicEditBtn');
    const clrBtn   = document.getElementById('topicClearBtn');

    if (row)  row.style.display  = topicVisible ? 'grid' : 'none';

    if (editBtn) editBtn.style.display = isHost ? 'inline-flex' : 'none';
    if (clrBtn)  clrBtn.style.display  = isHost ? 'inline-flex' : 'none';

    if (edit) edit.style.display = (isHost && isEditingTopic) ? 'grid' : 'none';
  }

  function parseTopicInput(raw){
    if (!raw) return { label:null, url:null };
    const s = String(raw).trim();
    if (/^https?:\/\//i.test(s)) {
      const m = s.match(/[A-Z][A-Z0-9]+-\d+/);
      return { label: (m ? m[0] : s), url: s };
    }
    return { label: s, url: null };
  }

  function syncParticipationUI(on){
    const st  = document.getElementById('partStatus');
    const cb  = document.getElementById('participationToggle');
    myParticipating = !!on;
    if (st) st.textContent = on ? TXT_IM_IN : TXT_OBSERVER;
    if (cb) {
      cb.checked = !!on;
      cb.setAttribute('aria-checked', on ? 'true' : 'false');
    }
    if (!myParticipating) clearCardSelection();
    updateCardInteractivity(myParticipating);
    highlightSelectedCard();
  }

  document.addEventListener('DOMContentLoaded', () => {
    syncSequenceUI();
    syncAutoRevealUI();
    syncTopicToggleUI();   // NEW: ensure topic switch is greyed out for non-hosts
    applyTopicUI();

    document.getElementById('seqChoice')?.addEventListener('change', (e)=>{
      const val = e.target?.value;
      if (!val) return;
      if (!isHost) { showToast(/*[[#{sequence.onlyHost}]]*/ 'Only the host can change the sequence'); syncSequenceUI(); return; }
      socket.send('setSequence:' + val);
    });

    const arRow = document.getElementById('autoRevealRow');
    const arToggle = document.getElementById('autoRevealToggle');
    arRow?.addEventListener('click', (e)=>{ if (!isHost) { e.preventDefault(); e.stopPropagation(); showToast(TXT_AR_ONLY_HOST); }});
    arToggle?.addEventListener('click', ()=>{ if (isHost) socket.send('setAutoReveal:' + !autoRevealEnabled); });

    const tvRow = document.getElementById('topicToggleRow');
    const tvCb  = document.getElementById('topicToggle');
    tvRow?.addEventListener('click', (e)=>{ if (!isHost) { e.preventDefault(); e.stopPropagation(); showToast(TXT_AR_ONLY_HOST); }});
    tvCb?.addEventListener('click', ()=>{ if (isHost) socket.send('setTopicVisible:' + !topicVisible); });

    const inEl    = document.getElementById('topicInput');
    const saveBtn = document.getElementById('topicSaveBtn');
    const cancel  = document.getElementById('topicCancelBtn');
    const editBtn = document.getElementById('topicEditBtn');
    const clearBtn= document.getElementById('topicClearBtn');

    editBtn?.addEventListener('click', ()=>{ if (!isHost) return; isEditingTopic = true; applyTopicUI(); inEl?.focus(); });
    cancel?.addEventListener('click', ()=>{ isEditingTopic = false; applyTopicUI(); });

    saveBtn?.addEventListener('click', ()=>{
      if (!isHost) return;
      const { label, url } = parseTopicInput(inEl?.value || '');
      const enc = encodeURIComponent(label || '') + '|' + encodeURIComponent(url || '');
      socket.send('setTopic:' + enc);
      isEditingTopic = false;
      if (inEl) inEl.value = '';
      showToast(TXT_TOPIC_SAVED);
    });
    inEl?.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter') { e.preventDefault(); saveBtn?.click(); }
    });
    clearBtn?.addEventListener('click', ()=>{
      if (!isHost) return;
      socket.send('clearTopic');
      showToast(TXT_TOPIC_CLEARED);
    });

    const partToggle = document.getElementById('participationToggle');
    partToggle?.addEventListener('click', ()=>{ const next = !myParticipating; syncParticipationUI(next); socket.send('setParticipating:' + next); });

    try {
      fetch('/sequences').then(r => r.ok ? r.json() : null).then(json => {
        if (!json) return;
        const obj = json.sequences || json;
        if (obj && typeof obj === 'object') { Object.assign(SEQ_CATALOG, obj); updateSequenceTooltips(); }
      }).catch(()=>{});
    } catch(e){}
  });

  const cid = (function(){
    try {
      const KEY = 'ep-cid';
      let id = sessionStorage.getItem(KEY);
      if (!id) {
        id = (crypto.randomUUID ? crypto.randomUUID()
             : (Math.random().toString(36).slice(2) + "-" + Date.now()));
        sessionStorage.setItem(KEY, id);
      }
      return id;
    } catch(e){
      return Math.random().toString(36).slice(2) + "-" + Date.now();
    }
  })();

  const wsProtocol = location.protocol === "https:" ? "wss://" : "ws://";
  const socketUrl = wsProtocol + location.host
    + "/gameSocket?roomCode=" + encodeURIComponent(roomCode)
    + "&participantName=" + encodeURIComponent(participantName)
    + "&cid=" + encodeURIComponent(cid);
  const socket = new WebSocket(socketUrl);

  const MSG_HOST_YOU   = /*[[#{toast.youAreHost}]]*/ 'Host changed. You are now host!';
  const MSG_HOST_OTHER = /*[[#{toast.hostOther}]]*/ 'Host changed. {new} is now host.';

  socket.onmessage = (event) => {
    const data = JSON.parse(event.data);

    if (data.type === 'you' && typeof data.yourName === 'string') {
      if (!data.cid || data.cid === cid) {
        if (data.yourName !== participantName) {
          participantName = data.yourName;
          const youEl = document.getElementById("youName");
          if (youEl) youEl.textContent = participantName;
        }
      }
      return;
    }

    if (Array.isArray(data.participants) && data.type !== "voteUpdate") {
      const revealed = !!data.votesRevealed;
      updateParticipantList(data.participants, revealed);
    }

    if (data.sequenceId) {
      const newSig = deckSig(data.cards);
      const needRerender = (currentSequenceId !== data.sequenceId) || (newSig && newSig !== currentDeckSig);
      currentSequenceId = data.sequenceId;
      if (Array.isArray(data.cards)) {
        SEQ_CATALOG[data.sequenceId] = data.cards.slice();
        updateSequenceTooltips();
      }
      if (needRerender && Array.isArray(data.cards)) {
        clearCardSelection();
        renderCards(data.cards);
        currentDeckSig = newSig;
      }
    }

    if (data.sequences && typeof data.sequences === 'object') {
      Object.assign(SEQ_CATALOG, data.sequences);
      updateSequenceTooltips();
    }

    if (typeof data.yourName === 'string' && data.cid && data.cid === cid) {
      if (data.yourName !== participantName) {
        participantName = data.yourName;
        const youEl = document.getElementById("youName");
        if (youEl) youEl.textContent = participantName;
      }
    }

    if (data.type === "voteUpdate") {
      const prevVotesRevealed = votesRevealed;
      const participants = Array.isArray(data.participants) ? data.participants : [];

      votesRevealed = data.votesRevealed;
      isHost = participants.find(p => p.name === participantName)?.isHost === true;

      if (typeof data.autoRevealEnabled === 'boolean') autoRevealEnabled = data.autoRevealEnabled;
      if (typeof data.topicVisible      === 'boolean') topicVisible      = data.topicVisible;

      syncAutoRevealUI();
      syncSequenceUI();
      syncTopicToggleUI();     // NEW: keep topic toggle visuals in sync with host status

      updateTopicDisplay(data.topicLabel || null, data.topicUrl || null);
      applyTopicUI();

      const me = participants.find(p => p.name === participantName);
      const serverParticipating = me ? (me.participating !== false) : true;
      syncParticipationUI(serverParticipating);

      document.getElementById("revealButton").style.display = isHost && !votesRevealed ? "inline-block" : "none";
      document.getElementById("resetButton").style.display  = isHost && votesRevealed ? "inline-block"  : "none";

      updateParticipantList(participants, votesRevealed);

      if (votesRevealed) {
        updateCardInteractivity(myParticipating);
        showResults(participants, data.averageVote);
      } else {
        toggleView(false);
        updateAverage(null);
        setConsensusUI(false);
        updateStatsUI(null);
        updateCardInteractivity(myParticipating);
      }

      if (prevVotesRevealed && !votesRevealed) clearCardSelection();
      highlightSelectedCard();

    } else if (data.type === "hostChanged") {
      const { oldHost, newHost } = data;
      const iBecomeHost = (newHost === participantName);
      const iLoseHost   = (oldHost === participantName);
      if (iBecomeHost || iLoseHost) {
        isHost = iBecomeHost;
        document.getElementById("revealButton").style.display = isHost && !votesRevealed ? "inline-block" : "none";
        document.getElementById("resetButton").style.display  = isHost && votesRevealed ? "inline-block"  : "none";
        syncSequenceUI();
        syncAutoRevealUI();
        syncTopicToggleUI();   // NEW: also update topic toggle on host change
        applyTopicUI();
      }
      showToast(newHost === participantName ? MSG_HOST_YOU : MSG_HOST_OTHER.replace('{new}', newHost));

    } else if (data.type === "kicked") {
      try { localStorage.setItem('ep-toast', TXT_KICKED); } catch(e) {}
      const target = data.redirect || "/";
      location.replace(target);

    } else if (data.type === "roomClosed") {
      const target = data.redirect || "/";
      location.replace(target);
    }
  };

  document.addEventListener('DOMContentLoaded', () => {
    const closeBtn = document.getElementById('closeRoomBtn');
    closeBtn?.addEventListener('click', () => {
      if (!isHost) return;
      const ok = confirm(/*[[#{room.close.confirm}]]*/ "Close this room for everyone now?");
      if (ok) socket.send("closeRoom");
    });
  });

  function sendVote(cardValue) {
    if (!myParticipating) { showToast(TXT_OBS_NO_PICK); return; }
    if (votesRevealed) return;
    socket.send("vote:" + participantName + ":" + cardValue);
    selectedCard = cardValue;
    highlightSelectedCard();
  }
  function clearCardSelection(){
    selectedCard = null;
    try { localStorage.removeItem('selectedCard'); } catch(e){}
    highlightSelectedCard();
  }
  function highlightSelectedCard() {
    document.querySelectorAll(".card-grid button").forEach(btn => {
      const card = btn.getAttribute("data-card");
      const isSelected = myParticipating && !votesRevealed && (card === selectedCard);
      btn.classList.toggle("selected", isSelected);
    });
  }
  function revealCards() { if (isHost) socket.send("revealCards"); }
  function resetRoom()   { if (isHost) socket.send("resetRoom"); clearCardSelection(); }

  function transferHost(name){
    if (!isHost || !name || name === participantName) return;
    socket.send("transferHost:" + name);
  }
  function kick(name){
    if (!isHost || !name || name === participantName) return;
    socket.send("kick:" + name);
  }

  function updateParticipantList(participants, revealed) {
    const list = document.getElementById("liveParticipantList");
    if (!list) return;
    list.innerHTML = "";
    participants.forEach(p => {
      const li = document.createElement("li");
      li.classList.add("participant-row");
      li.dataset.hasvote = p.vote !== null;
      if (p.disconnected) li.classList.add("disconnected");
      if (p.isHost) li.classList.add("is-host");

      const icon = document.createElement("span");
      icon.className = p.isHost ? "participant-icon host" : (p.disconnected ? "participant-icon inactive" : "participant-icon");
      icon.textContent = p.isHost ? "ğŸ‘‘" : (p.disconnected ? "ğŸ’¤" : "ğŸ‘¤");

      const nameSpan = document.createElement("span");
      nameSpan.className = "name";
      nameSpan.textContent = p.name;

      const rightWrap = document.createElement("div");
      rightWrap.className = "row-right";

      if (revealed) {
        if (p.participating === false) {
          const status = document.createElement("span");
          status.className = "status-icon observer";
          status.textContent = "ğŸ‘€";
          rightWrap.appendChild(status);
        } else {
          const voteChip = document.createElement("span");
          voteChip.className = "vote-chip";
          const v = p.vote != null ? String(p.vote) : null;
          const n = v != null ? parseVoteNumeric(v) : null;
          const isNumeric = n != null;
          voteChip.textContent = v != null ? v : "â€”";
          voteChip.dataset.val = v != null ? v : "";
          if (isNumeric) {
            voteChip.dataset.num = String((Math.round(n * 1000) / 1000).toFixed(3));
          } else {
            voteChip.classList.add("special");
          }
          rightWrap.appendChild(voteChip);
        }
      } else {
        if (!p.disconnected) {
          if (p.participating === false) {
            const status = document.createElement("span");
            status.className = "status-icon observer";
            status.textContent = "ğŸ‘€";
            rightWrap.appendChild(status);
          } else if (p.vote != null) {
            const status = document.createElement("span");
            status.className = "status-icon done";
            status.textContent = "âœ…";
            rightWrap.appendChild(status);
          } else {
            const status = document.createElement("span");
            status.className = "status-icon pending";
            status.textContent = "â³";
            rightWrap.appendChild(status);
          }
        }
      }

      const actions = document.createElement("div");
      actions.className = "row-actions";

      if (isHost && !p.isHost && p.name !== participantName) {
        const mk = document.createElement("button");
        mk.type = "button";
        mk.className = "row-action host";
        mk.setAttribute("aria-label", TXT_MAKE_HOST + ": " + p.name);
        mk.setAttribute("data-tooltip", TXT_MAKE_HOST);
        const ic = document.createElement("span"); ic.className = "ra-icon";  ic.textContent = "ğŸ‘‘";
        const lab = document.createElement("span"); lab.className = "ra-label"; lab.textContent = TXT_MAKE_HOST;
        mk.appendChild(ic); mk.appendChild(lab);
        mk.addEventListener("click", () => transferHost(p.name));
        actions.appendChild(mk);

        const kb = document.createElement("button");
        kb.type = "button";
        kb.className = "row-action kick";
        kb.setAttribute("aria-label", TXT_KICK + ": " + p.name);
        kb.setAttribute("data-tooltip", TXT_KICK);
        const ic2 = document.createElement("span"); ic2.className = "ra-icon"; ic2.textContent = "âŒ";
        const lab2 = document.createElement("span"); lab2.className = "ra-label"; lab2.textContent = TXT_KICK;
        kb.appendChild(ic2); kb.appendChild(lab2);
        kb.addEventListener("click", () => kick(p.name));
        actions.appendChild(kb);
      }

      if (actions.childElementCount) rightWrap.appendChild(actions);

      li.appendChild(icon);
      li.appendChild(nameSpan);
      li.appendChild(rightWrap);
      list.appendChild(li);
    });
    measureAndSetNameColumn();
  }

  function measureAndSetNameColumn() {
    const list = document.getElementById("liveParticipantList");
    if (!list) return;
    const names = Array.from(list.querySelectorAll(".name"));
    const maxTextWidth = names.reduce((m, el) => Math.max(m, el.offsetWidth || 0), 0);
    list.style.setProperty("--name-text-col", Math.ceil(maxTextWidth) + "px");
  }
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer); resizeTimer = setTimeout(measureAndSetNameColumn, 150);
  });

  function updateAverage(avg) {
    const avgSpan = document.getElementById("averageVote");
    if (avgSpan) avgSpan.textContent = avg != null ? avg : "-";
  }
  function setConsensusUI(on){
    const row = document.getElementById("resultRow");
    const lbl = document.getElementById("resultLabel");
    if (!row || !lbl) return;
    lbl.textContent = on ? TXT_CONS : TXT_AVG;
    row.classList.toggle("consensus", !!on);
  }
  function parseVoteNumeric(s){
    if (!s) return null;
    s = String(s).trim();
    if (SPECIALS.has(s)) return null;
    if (s === "Â½" || s === "1/2" || s === "0,5") return 0.5;
    if (/^\d+\s*\/\s*\d+$/.test(s)) {
      const [a,b] = s.split("/").map(x=>parseFloat(x.replace(',','.')));
      return b ? (a/b) : null;
    }
    const n = parseFloat(s.replace(',','.'));
    return Number.isFinite(n) ? n : null;
  }
  function hasConsensus(participants){
    const active = participants.filter(p => !p.disconnected && p.participating !== false);
    if (!active.length) return false;
    const nums = [];
    for (const p of active) {
      if (p.vote == null) return false;
      const n = parseVoteNumeric(p.vote);
      if (n == null) return false;
      nums.push(Math.round(n*1000)/1000);
    }
    return nums.every(v => v === nums[0]);
  }
  function applyConsensusUI(isOn){
    setConsensusUI(isOn);
    if (isOn) { updateStatsUI(null); markOutliers(null); }
  }
  function fmt(n){
    if (n == null || !Number.isFinite(n)) return "-";
    const r = Math.round(n * 100) / 100;
    return Number.isInteger(r) ? String(r) : String(r);
  }
  function computeStats(participants){
    const nums = [];
    for (const p of participants) {
      if (p && !p.disconnected && p.participating !== false) {
        const n = parseVoteNumeric(p.vote);
        if (n != null) nums.push(Math.round(n*1000)/1000);
      }
    }
    if (nums.length < 1) return null;
    const a = nums.slice().sort((x,y)=>x-y);
    const min = a[0], max = a[a.length-1];
    let median;
    if (a.length % 2 === 1) median = a[(a.length-1)/2];
    else median = (a[a.length/2 - 1] + a[a.length/2]) / 2;
    const mean = a.reduce((s,v)=>s+v,0)/a.length;
    const deltas = a.map(v => Math.abs(v - mean));
    const maxDelta = Math.max(...deltas);
    const outlierNums = new Set(
      a.filter((v)=>Math.abs(v-mean) === maxDelta)
       .map(v => String((Math.round(v*1000)/1000).toFixed(3)))
    );
    return { median, rangeMin: min, rangeMax: max, outlierNums };
  }
  function updateStatsUI(stats){
    const mWrap = document.getElementById('medianWrap');
    const rWrap = document.getElementById('rangeWrap');
    const rSep  = document.getElementById('rangeSep');
    const mLbl  = document.getElementById('medianLabel');
    const rLbl  = document.getElementById('rangeLabel');
    const mVal  = document.getElementById('medianVote');
    const rVal  = document.getElementById('rangeVote');
    if (!mWrap || !rWrap || !mVal || !rVal || !mLbl || !rLbl) return;
    if (!stats) { mWrap.hidden = true; rWrap.hidden = true; rSep.hidden = true; return; }
    mLbl.textContent = TXT_MEDIAN;
    rLbl.textContent = TXT_RANGE;
    mVal.textContent = fmt(stats.median);
    rVal.textContent = fmt(stats.rangeMin) + "â€“" + fmt(stats.rangeMax);
    mWrap.hidden = false; rWrap.hidden = false; rSep.hidden = false;
  }
  function markOutliers(outlierNums){
    document.querySelectorAll('.vote-chip.outlier').forEach(el => { el.classList.remove('outlier'); el.removeAttribute('data-tooltip'); });
    if (!outlierNums || !outlierNums.size) return;
    document.querySelectorAll('#liveParticipantList .vote-chip[data-num]').forEach(chip=>{
      const norm = chip.getAttribute('data-num');
      if (outlierNums.has(norm)) { chip.classList.add('outlier'); chip.setAttribute('data-tooltip', TXT_OUTLIER_HINT); }
    });
  }
  function toggleView(revealed) {
    document.querySelectorAll(".pre-vote").forEach(e => e.style.display = revealed ? "none" : "block");
    document.querySelectorAll(".post-vote").forEach(e => e.style.display = revealed ? "block" : "none");
    const h = document.getElementById("selectCardHeader"); if (h) h.style.display = revealed ? "none" : "block";
  }
  function showResults(participants, avg) {
    toggleView(true);
    updateAverage(avg);
    const consensus = hasConsensus(participants);
    applyConsensusUI(consensus);
    if (!consensus) {
      const stats = computeStats(participants);
      updateStatsUI(stats);
      markOutliers(stats ? stats.outlierNums : null);
    }
  }

  function showToast(message) {
    const toast = document.createElement("div");
    toast.className = "toast";
    document.body.appendChild(toast);
    toast.textContent = message;
    setTimeout(() => toast.remove(), 3000);
  }

  (function(){
    const copyBtn = document.getElementById('copyRoomLink');
    const TXT_LINK_COPIED = /*[[#{invite.linkCopied}]]*/ 'Link copied to clipboard';
    const TXT_COPY_FAILED = /*[[#{notify.copyFailed}]]*/ 'Copy failed';
    function deepLink(){ return location.origin + "/room?roomCode=" + encodeURIComponent(roomCode); }
    async function copyText(text){
      try{ await navigator.clipboard.writeText(text); showToast(TXT_LINK_COPIED); }
      catch(e){ showToast(TXT_COPY_FAILED); }
    }
    copyBtn?.addEventListener('click', ()=>copyText(deepLink()));
  })();
  </script>

  <!-- Footer include (centralized) -->
<div th:replace="~{fragments/footer :: footer}"></div>


</body>
</html>
