<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" th:lang="${#locale}" lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="dark light">
  <title th:text="#{app.title}">RBS' Estimation Poker</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="alternate icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <script>
    (function(){try{
      var t=localStorage.getItem('estpoker-theme')||'dark';
      if(t==='system')document.documentElement.removeAttribute('data-theme');
      else document.documentElement.setAttribute('data-theme',t);
    }catch(e){}})();
  </script>
  <link rel="stylesheet" th:href="@{/styles.css}">
</head>
<body>
<button id="menuButton" class="menu-button" aria-expanded="false" aria-controls="appMenuOverlay" aria-label="Open menu">☰</button>

<!-- Overlay Menu -->
<div id="appMenuOverlay" class="menu-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="menuTitle">
  <div class="menu-backdrop" data-close></div>
  <div class="menu-panel">
    <div class="menu-header">
      <h3 id="menuTitle" th:text="#{menu.title}">Settings</h3>
    </div>

    <div class="menu-section">
      <!-- Language -->
      <button id="langRow" class="menu-item" type="button" aria-label="Switch language">
        <span class="mi-icon">
          <span class="flag-split" aria-hidden="true">
            <img class="flag flag-a" src="/flags/us.svg" alt="">
            <img class="flag flag-b" src="/flags/gb.svg" alt="">
          </span>
        </span>
        <span><span th:text="#{menu.language}">Language</span>: <strong id="langCurrent">English</strong></span>
      </button>

      <!-- Theme -->
      <div class="menu-group">
        <div class="group-title" th:text="#{menu.theme}">Theme</div>
        <div class="menu-choice">
          <button id="themeLight"  class="choice-btn" type="button"><span class="mi-icon" aria-hidden="true">🌞</span><span th:text="#{theme.light}">Light</span></button>
          <button id="themeDark"   class="choice-btn" type="button"><span class="mi-icon" aria-hidden="true">🌙</span><span th:text="#{theme.dark}">Dark</span></button>
          <button id="themeSystem" class="choice-btn" type="button"><span class="mi-icon" aria-hidden="true">🖥️</span><span th:text="#{theme.system}">System</span></button>
        </div>
      </div>

      <!-- Card sequence -->
      <div class="menu-group">
        <div class="group-title" th:text="#{menu.sequence}">Card sequence</div>
        <div id="seqChoice" class="menu-choice vertical">
          <label class="radio-row">
            <input type="radio" name="seq" value="fib-scrum" checked>
            <span th:text="#{sequence.fib.scrum}">Fibonacci (Scrum)</span>
          </label>
          <label class="radio-row">
            <input type="radio" name="seq" value="fib-enh">
            <span th:text="#{sequence.fib.enh}">Fibonacci (Scrum enhanced)</span>
          </label>
          <label class="radio-row">
            <input type="radio" name="seq" value="fib-orig">
            <span th:text="#{sequence.fib.orig}">Fibonacci (mathematical)</span>
          </label>
          <label class="radio-row">
            <input type="radio" name="seq" value="pow2">
            <span th:text="#{sequence.pow2}">Powers of 2</span>
          </label>
          <label class="radio-row">
            <input type="radio" name="seq" value="tshirt">
            <span th:text="#{sequence.tshirt}">T-Shirt sizes</span>
          </label>
        </div>
        <p id="seqHint" class="hint" th:text="#{sequence.onlyHost}">Only the host can change the sequence</p>
      </div>

      <!-- Invite -->
      <div class="menu-group">
        <div class="group-title" th:text="#{menu.invite}">Invite</div>
        <button id="copyRoomLink" class="menu-item" type="button">
          <span class="mi-icon" aria-hidden="true">🔗</span>
          <span th:text="#{invite.copyLink}">Copy link to this room</span>
        </button>
      </div>

      <!-- Room actions (host only) -->
      <div class="menu-group">
        <div class="group-title" th:text="#{menu.room}">Room</div>
        <button id="closeRoomBtn" class="menu-item danger" type="button" style="display:none;">
          <span class="mi-icon" aria-hidden="true">🗙</span>
          <span th:text="#{room.close}">Close room for everyone</span>
        </button>
        <p id="closeHint" class="hint" style="display:none;" th:text="#{room.close.hint}">
          Closes this room for all participants and returns to the start page.
        </p>
      </div>
    </div>
  </div>
</div>

<div class="container">
  <h1 class="app-title">
    <img src="/favicon.svg" alt="" width="24" height="24" class="logo">
    <span th:text="#{ui.heading}">RBS' Estimation Poker</span>
  </h1>

  <!-- Info -->
  <dl class="main-info">
    <dt><span class="mi-icon" aria-hidden="true">👤</span><span class="mi-label" th:text="#{label.you}">You are:</span></dt>
    <dd><strong id="youName" th:text="${participantName}">Guest</strong></dd>

    <dt><span class="mi-icon" aria-hidden="true">🆔</span><span class="mi-label" th:text="#{label.room}">Room:</span></dt>
    <dd><strong id="roomCodeVal" th:text="${roomCode}">demo</strong></dd>
  </dl>

  <h2 th:text="#{label.participants}">Participants</h2>
  <ul id="liveParticipantList"></ul>

  <h2 id="selectCardHeader" th:text="#{label.selectCard}">Choose a card:</h2>

  <div class="pre-vote">
    <!-- Erst-Buttons (ohne grünen Haken) -->
    <div id="cardsArea">
      <div class="card-grid">
        <button type="button" th:each="cardValue : ${cardsRow1}"
                th:text="${cardValue}" th:attr="data-card=${cardValue}"
                th:onclick="|sendVote(this.getAttribute('data-card'))|">1</button>
      </div>
      <div class="card-grid">
        <button type="button" th:each="cardValue : ${cardsRow2}"
                th:text="${cardValue}" th:attr="data-card=${cardValue}"
                th:onclick="|sendVote(this.getAttribute('data-card'))|">2</button>
      </div>
      <div class="card-grid">
        <button type="button" th:each="cardValue : ${cardsRow3}"
                th:text="${cardValue}" th:attr="data-card=${cardValue}"
                th:onclick="|sendVote(this.getAttribute('data-card'))|">3</button>
      </div>
    </div>

    <button type="button" id="revealButton" class="button" style="display:none;"
            th:text="#{button.reveal}" onclick="revealCards()">Reveal cards</button>
  </div>

  <div class="post-vote" style="display:none;">
    <!-- Ergebniszeile: screenreader-freundlich + für Konsens umschaltbar -->
    <p id="resultRow"
       class="average-label consensus-row"
       role="status"
       aria-live="polite"
       aria-atomic="true">
      <span id="resultLabel" class="label" th:text="#{label.average}">Avg:</span>
      <span id="averageVote" class="value">–</span>
    </p>

    <button type="button" id="resetButton" class="button" style="display:none;"
            th:text="#{button.reset}" onclick="resetRoom()">Start new round</button>
  </div>
</div>

<script th:inline="javascript">
/* ===== Menu (morph + focus trap) ===== */
(function(){
  const btn = document.getElementById('menuButton');
  const overlay = document.getElementById('appMenuOverlay');
  const panel = overlay?.querySelector('.menu-panel');
  const backdrop = overlay?.querySelector('[data-close]');
  let lastFocus = null;

  function focusables(){ return panel.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'); }
  function trapTab(e){
    if (e.key !== 'Tab' || overlay.classList.contains('hidden')) return;
    const f = focusables(); if (!f.length) return;
    const first = f[0], last = f[f.length-1];
    if (e.shiftKey && document.activeElement === first) { last.focus(); e.preventDefault(); }
    else if (!e.shiftKey && document.activeElement === last) { first.focus(); e.preventDefault(); }
  }
  function openMenu(){
    document.body.classList.add('menu-open');
    overlay.classList.remove('hidden');
    btn.classList.add('open');
    btn.setAttribute('aria-expanded','true');
    btn.setAttribute('aria-label', /*[[#{menu.close}]]*/ 'Close menu');
    btn.textContent = '✕';
    lastFocus = document.activeElement;
    setTimeout(()=>focusables()[0]?.focus(), 0);
    window.addEventListener('keydown', trapTab);
  }
  function closeMenu(){
    document.body.classList.remove('menu-open');
    overlay.classList.add('hidden');
    btn.classList.remove('open');
    btn.setAttribute('aria-expanded','false');
    btn.setAttribute('aria-label', /*[[#{menu.open}]]*/ 'Open menu');
    btn.textContent = '☰';
    window.removeEventListener('keydown', trapTab);
    lastFocus?.focus();
  }
  function toggleMenu(){ overlay.classList.contains('hidden') ? openMenu() : closeMenu(); }

  btn?.addEventListener('click', toggleMenu);
  backdrop?.addEventListener('click', closeMenu);
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeMenu(); });

  window.__closeMenuIfOpen = () => { if (!overlay.classList.contains('hidden')) closeMenu(); };
})();

/* ===== Theme ===== */
(function(){
  const bLight  = document.getElementById('themeLight');
  const bDark   = document.getElementById('themeDark');
  const bSystem = document.getElementById('themeSystem');

  function applyTheme(t){
    if (t === 'system') document.documentElement.removeAttribute('data-theme');
    else document.documentElement.setAttribute('data-theme', t);
    try { localStorage.setItem('estpoker-theme', t); } catch(e){}
    [bLight,bDark,bSystem].forEach(x=>x&&x.classList.remove('active'));
    ({light:bLight, dark:bDark, system:bSystem}[t||'dark'])?.classList.add('active');
  }

  document.addEventListener('DOMContentLoaded', function(){
    const saved = localStorage.getItem('estpoker-theme') || 'dark';
    ({light:bLight, dark:bDark, system:bSystem}[saved])?.classList.add('active');
    bLight?.addEventListener('click', ()=>applyTheme('light'));
    bDark?.addEventListener('click',  ()=>applyTheme('dark'));
    bSystem?.addEventListener('click',()=>applyTheme('system'));
  });
})();

/* ===== Language: POST /i18n ===== */
(function(){
  const row   = document.getElementById('langRow');
  const cur   = (document.documentElement.lang || 'en').toLowerCase();
  const a     = row?.querySelector('.flag-a');
  const b     = row?.querySelector('.flag-b');
  const label = document.getElementById('langCurrent');

  function setSplit(lang){
    if (!a || !b) return;
    if (String(lang).startsWith('de')) { a.src='/flags/de.svg'; b.src='/flags/at.svg'; if (label) label.textContent='Deutsch'; }
    else { a.src='/flags/us.svg'; b.src='/flags/gb.svg'; if (label) label.textContent='English'; }
  }
  function nextLang(){ return cur.startsWith('de') ? 'en' : 'de'; }
  function switchLang(to){
    fetch('/i18n', { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body:'lang='+encodeURIComponent(to) })
      .finally(()=>location.reload());
  }

  document.addEventListener('DOMContentLoaded', function(){
    setSplit(cur);
    row?.addEventListener('click', function(){
      const to = nextLang();
      setSplit(to);
      switchLang(to);
    });
  });
})();

/* ===== Game logic ===== */
let participantName = /*[[${participantName}]]*/ "Guest";
let roomCode = /*[[${roomCode}]]*/ "demo";
let selectedCard = null;
let votesRevealed = false;
let isHost = false;
let resizeTimer = null;
let currentSequenceId = 'fib-scrum'; // server overwrites
let currentDeckSig = "";             // track current deck

const SPECIALS = new Set(["❓","💬","☕"]);

/** i18n Fallbacks für die Labels */
const TXT_AVG  = /*[[#{label.average}]]*/ 'Avg:';
const TXT_CONS = /*[[#{label.consensus}]]*/ 'Consensus:';

/** Button Helper (kein grüner Haken mehr) */
function addCardButton(grid, val){
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.setAttribute('data-card', val);
  btn.onclick = () => sendVote(val);
  btn.textContent = val;
  grid.appendChild(btn);
}

/** Deck-Signatur */
function deckSig(arr){ return Array.isArray(arr) ? arr.join("|") : ""; }

/** Render: Desktop auto-fit; Specials in eigener Zeile */
function renderCards(deck){
  const area = document.getElementById('cardsArea');
  if (!area || !Array.isArray(deck)) return;

  const regular = deck.filter(v => !SPECIALS.has(v));
  const specials = deck.filter(v =>  SPECIALS.has(v));

  area.innerHTML = '';

  const grid = document.createElement('div');
  grid.className = 'card-grid';
  regular.forEach(val => addCardButton(grid, val));
  area.appendChild(grid);

  if (specials.length){
    const sgrid = document.createElement('div');
    sgrid.className = 'card-grid';
    specials.forEach(val => addCardButton(sgrid, val));
    area.appendChild(sgrid);
  }

  highlightSelectedCard();
}

function syncSequenceUI(){
  const radios = document.querySelectorAll('#seqChoice input[name="seq"]');
  radios.forEach(r => {
    r.checked = (r.value === currentSequenceId);
    r.disabled = !isHost;
    r.closest('.radio-row')?.classList.toggle('disabled', !isHost);
  });
  const hint = document.getElementById('seqHint');
  if (hint) hint.style.display = isHost ? 'none' : 'block';
}

document.addEventListener('DOMContentLoaded', () => {
  syncSequenceUI();
  const seqChoice = document.getElementById('seqChoice');
  seqChoice?.addEventListener('change', (e)=>{
    const val = e.target?.value;
    if (!val) return;
    if (!isHost) { showToast(/*[[#{sequence.onlyHost}]]*/ 'Only the host can change the sequence'); syncSequenceUI(); return; }
    socket.send('setSequence:' + val);
  });
});

// stabile Client-ID
const cid = (function(){
  try {
    let id = localStorage.getItem('ep-cid');
    if (!id) {
      id = (crypto.randomUUID ? crypto.randomUUID()
           : (Math.random().toString(36).slice(2) + Date.now()));
      localStorage.setItem('ep-cid', id);
    }
    return id;
  } catch(e){
    return Math.random().toString(36).slice(2) + Date.now();
  }
})();

const wsProtocol = location.protocol === "https:" ? "wss://" : "ws://";
const socketUrl = wsProtocol + location.host
  + "/gameSocket?roomCode=" + encodeURIComponent(roomCode)
  + "&participantName=" + encodeURIComponent(participantName)
  + "&cid=" + encodeURIComponent(cid);
const socket = new WebSocket(socketUrl);

socket.onopen = () => console.log("✅ Connected");

const MSG_HOST_YOU   = /*[[#{toast.youAreHost}]]*/ 'Host {old} left. You are now host!';
const MSG_HOST_OTHER = /*[[#{toast.hostOther}]]*/ 'Host {old} left. {new} is now host.';

socket.onmessage = (event) => {
  const data = JSON.parse(event.data);

  // Sequenz + Karten
  if (data.sequenceId) {
    const newSig = deckSig(data.cards);
    const needRerender =
      (currentSequenceId !== data.sequenceId) ||
      (newSig && newSig !== currentDeckSig);

    currentSequenceId = data.sequenceId;
    syncSequenceUI();

    if (needRerender && Array.isArray(data.cards)) {
      clearCardSelection();
      renderCards(data.cards);
      currentDeckSig = newSig;
    }
  }

  if (data.yourName && data.yourName !== participantName) {
    participantName = data.yourName;
    const youEl = document.getElementById("youName");
    if (youEl) youEl.textContent = participantName;
  }

  if (data.type === "voteUpdate") {
    const prevVotesRevealed = votesRevealed;
    const participants = Array.isArray(data.participants) ? data.participants : [];

    votesRevealed = data.votesRevealed;
    isHost = participants.find(p => p.name === participantName)?.isHost === true;

    document.getElementById("revealButton").style.display = isHost && !votesRevealed ? "inline-block" : "none";
    document.getElementById("resetButton").style.display  = isHost && votesRevealed ? "inline-block" : "none";

    const closeBtn = document.getElementById('closeRoomBtn');
    const closeHint = document.getElementById('closeHint');
    if (closeBtn) closeBtn.style.display = isHost ? 'grid' : 'none';
    if (closeHint) closeHint.style.display = isHost ? 'block' : 'none';

    updateParticipantList(participants, votesRevealed);

    if (votesRevealed) {
      showResults(participants, data.averageVote);
    } else {
      toggleView(false);
      updateAverage(null);
      setConsensusUI(false);  // Label zurück auf Avg
    }

    if (prevVotesRevealed && !votesRevealed) clearCardSelection();

    highlightSelectedCard();
  } else if (data.type === "hostChanged") {
    const { oldHost, newHost } = data;
    showToast(newHost === participantName
      ? MSG_HOST_YOU.replace('{old}', oldHost)
      : MSG_HOST_OTHER.replace('{old}', oldHost).replace('{new}', newHost)
    );
  } else if (data.type === "roomClosed") {
    const target = data.redirect || "/";
    location.replace(target);
  }
};

// host-only action: close room
document.addEventListener('DOMContentLoaded', () => {
  const closeBtn = document.getElementById('closeRoomBtn');
  closeBtn?.addEventListener('click', () => {
    if (!isHost) return;
    const ok = confirm(/*[[#{room.close.confirm}]]*/ "Close this room for everyone now?");
    if (ok) socket.send("closeRoom");
  });
});

function sendVote(cardValue) { socket.send("vote:" + participantName + ":" + cardValue); selectedCard = cardValue; highlightSelectedCard(); }
function clearCardSelection(){ selectedCard = null; try { localStorage.removeItem('selectedCard'); } catch(e){} highlightSelectedCard(); }
function highlightSelectedCard() {
  document.querySelectorAll(".card-grid button").forEach(btn => {
    const card = btn.getAttribute("data-card");
    const isSelected = !votesRevealed && card === selectedCard;
    btn.classList.toggle("selected", isSelected);
  });
}
function revealCards() { if (isHost) socket.send("revealCards"); }
function resetRoom()   { if (isHost) socket.send("resetRoom"); clearCardSelection(); }

function updateParticipantList(participants, revealed) {
  const list = document.getElementById("liveParticipantList");
  if (!list) return;
  list.innerHTML = "";
  participants.forEach(p => {
    const li = document.createElement("li");
    li.classList.add("participant-row");
    li.dataset.hasvote = p.vote !== null;
    if (p.disconnected) li.classList.add("disconnected");
    if (p.isHost) li.classList.add("is-host");

    const icon = document.createElement("span");
    icon.className = p.isHost ? "participant-icon host" : (p.disconnected ? "participant-icon inactive" : "participant-icon");
    icon.textContent = p.isHost ? "👑" : (p.disconnected ? "💤" : "👤");

    const nameSpan = document.createElement("span"); nameSpan.className = "name"; nameSpan.textContent = p.name;
    const rightWrap = document.createElement("div"); rightWrap.className = "row-right";

    if (revealed) {
      const voteChip = document.createElement("span");
      voteChip.className = "vote-chip";
      const v = p.vote != null ? String(p.vote) : null;
      voteChip.textContent = v != null ? v : "—";
      voteChip.dataset.val = v != null ? v : "";
      if (v && !/^\d+$/.test(v)) voteChip.classList.add("special");
      rightWrap.appendChild(voteChip);
    } else {
      if (!p.disconnected && p.vote != null) {
        const status = document.createElement("span"); status.className = "status-icon done"; status.textContent = "✅";
        rightWrap.appendChild(status);
      } else if (!p.disconnected) {
        const status = document.createElement("span"); status.className = "status-icon pending"; status.textContent = "⏳";
        rightWrap.appendChild(status);
      }
    }

    li.appendChild(icon); li.appendChild(nameSpan); li.appendChild(rightWrap);
    list.appendChild(li);
  });
  measureAndSetNameColumn();
}
function measureAndSetNameColumn() {
  const list = document.getElementById("liveParticipantList");
  if (!list) return;
  const names = Array.from(list.querySelectorAll(".name"));
  const maxTextWidth = names.reduce((m, el) => Math.max(m, el.offsetWidth || 0), 0);
  list.style.setProperty("--name-text-col", Math.ceil(maxTextWidth) + "px");
}
window.addEventListener("resize", () => { clearTimeout(resizeTimer); resizeTimer = setTimeout(measureAndSetNameColumn, 150); });

/* „-“ statt „N/A“ */
function updateAverage(avg) {
  const avgSpan = document.getElementById("averageVote");
  if (avgSpan) avgSpan.textContent = avg != null ? avg : "-";
}

/* ===== Consensus-UI (Label & Farbe, Zahl bleibt die vom Server) ===== */
function setConsensusUI(on){
  const row = document.getElementById('resultRow');
  const lbl = document.getElementById('resultLabel');
  if (!row || !lbl) return;
  lbl.textContent = on ? TXT_CONS : TXT_AVG;
  row.classList.toggle('consensus', !!on);
}

/* Numerik-Parser für Consensus-Check */
function parseVoteNumeric(s){
  if (!s) return null;
  s = String(s).trim();
  if (SPECIALS.has(s)) return null;
  if (s === "½" || s === "1/2" || s === "0,5") return 0.5;
  if (/^\d+\s*\/\s*\d+$/.test(s)) {
    const [a,b] = s.split("/").map(x=>parseFloat(x.replace(',','.')));
    return b ? (a/b) : null;
  }
  const n = parseFloat(s.replace(',','.'));
  return Number.isFinite(n) ? n : null;
}

/* Prüft Consensus und toggelt UI */
function updateConsensus(participants){
  const active = participants.filter(p => !p.disconnected);
  if (!active.length) { setConsensusUI(false); return; }

  const nums = [];
  for (const p of active) {
    if (p.vote == null) { setConsensusUI(false); return; }
    const n = parseVoteNumeric(p.vote);
    if (n == null) { setConsensusUI(false); return; }
    nums.push(Math.round(n*1000)/1000);
  }
  const allSame = nums.every(v => v === nums[0]);
  setConsensusUI(allSame);
}

function toggleView(revealed) {
  document.querySelectorAll(".pre-vote").forEach(e => e.style.display = revealed ? "none" : "block");
  document.querySelectorAll(".post-vote").forEach(e => e.style.display = revealed ? "block" : "none");
  const h = document.getElementById("selectCardHeader"); if (h) h.style.display = revealed ? "none" : "block";
}
function showResults(participants, avg) {
  toggleView(true);
  updateAverage(avg);
  updateConsensus(participants);
}

function showToast(message) {
  const toast = document.createElement("div");
  toast.className = "toast";
  document.body.appendChild(toast);
  toast.textContent = message;
  setTimeout(() => toast.remove(), 3000);
}

/* Invite: Deep-Link only */
(function(){
  const copyBtn = document.getElementById('copyRoomLink');
  const TXT_LINK_COPIED = /*[[#{invite.linkCopied}]]*/ 'Link copied to clipboard';
  const TXT_COPY_FAILED = /*[[#{notify.copyFailed}]]*/ 'Copy failed';

  function deepLink(){ return location.origin + "/room?roomCode=" + encodeURIComponent(roomCode); }
  async function copyText(text){
    try{ await navigator.clipboard.writeText(text); showToast(TXT_LINK_COPIED); }
    catch(e){ console.warn(e); showToast(TXT_COPY_FAILED); }
  }
  copyBtn?.addEventListener('click', ()=>copyText(deepLink()));
})();
</script>

<!-- small toast css inlined + (deine Consensus-Styles sind in styles.css) -->
<style>
.toast{position:fixed;top:20px;right:20px;background-color:rgba(51,51,51,.95);color:#fff;padding:12px 20px;border-radius:10px;z-index:9999;font-size:14px;box-shadow:0 6px 16px rgba(0,0,0,.25);transform:translateY(-10px);opacity:0;animation:fadein .22s ease forwards,fadeout .4s ease 2.4s forwards}
@keyframes fadein{to{opacity:.95;transform:translateY(0)}}
@keyframes fadeout{to{opacity:0}}
</style>
</body>
</html>
